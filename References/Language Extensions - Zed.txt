 1.
 2. General
 3. Getting Started <https://zed.dev/docs/getting-started.html>
 4. System Requirements <https://zed.dev/docs/system-requirements.html>
 5. Linux <https://zed.dev/docs/linux.html>
 6. Windows <https://zed.dev/docs/windows.html>
 7. Telemetry <https://zed.dev/docs/telemetry.html>
 8. Workspace Persistence <https://zed.dev/docs/workspace-persistence.html>
 9. Additional Learning Materials <https://zed.dev/docs/additional-
    learning-materials.html>
10.
11. Configuration
12. Configuring Zed <https://zed.dev/docs/configuring-zed.html>
13. Configuring Languages <https://zed.dev/docs/configuring-languages.html>
14. Key bindings <https://zed.dev/docs/key-bindings.html>
15. Snippets <https://zed.dev/docs/snippets.html>
16. Themes <https://zed.dev/docs/themes.html>
17. Icon Themes <https://zed.dev/docs/icon-themes.html>
18. Vim Mode <https://zed.dev/docs/vim.html>
19.
20. Using Zed
21. Multibuffers <https://zed.dev/docs/multibuffers.html>
22. Outline Panel <https://zed.dev/docs/outline-panel.html>
23. Code Completions <https://zed.dev/docs/completions.html>
24. Channels <https://zed.dev/docs/channels.html>
25. Collaboration <https://zed.dev/docs/collaboration.html>
26. Git <https://zed.dev/docs/git.html>
27. Tasks <https://zed.dev/docs/tasks.html>
28. Remote Development <https://zed.dev/docs/remote-development.html>
29. Environment Variables <https://zed.dev/docs/environment.html>
30. REPL <https://zed.dev/docs/repl.html>
31.
32. Assistant
33. Overview <https://zed.dev/docs/assistant/assistant.html>
34. Configuration <https://zed.dev/docs/assistant/configuration.html>
35. Assistant Panel <https://zed.dev/docs/assistant/assistant-panel.html>
36. Contexts <https://zed.dev/docs/assistant/contexts.html>
37. Inline Assistant <https://zed.dev/docs/assistant/inline-assistant.html>
38. Commands <https://zed.dev/docs/assistant/commands.html>
39. Prompts <https://zed.dev/docs/assistant/prompting.html>
40. Context Servers <https://zed.dev/docs/assistant/context-servers.html>
41.
     1. Model Context Protocol <https://zed.dev/docs/assistant/model-
        context-protocol.html>
42. Model Improvement <https://zed.dev/docs/model-improvement.html>
43.
44. Extensions
45. Overview <https://zed.dev/docs/extensions.html>
46. Installing Extensions <https://zed.dev/docs/extensions/installing-
    extensions.html>
47. Developing Extensions <https://zed.dev/docs/extensions/developing-
    extensions.html>
48. Language Extensions <https://zed.dev/docs/extensions/languages.html>
49. Theme Extensions <https://zed.dev/docs/extensions/themes.html>
50. Icon Theme Extensions <https://zed.dev/docs/extensions/icon-themes.html>
51. Slash Command Extensions <https://zed.dev/docs/extensions/slash-
    commands.html>
52. Context Server Extensions <https://zed.dev/docs/extensions/context-
    servers.html>
53.
54. Language Support
55. All Languages <https://zed.dev/docs/languages.html>
56. Ansible <https://zed.dev/docs/languages/ansible.html>
57. AsciiDoc <https://zed.dev/docs/languages/asciidoc.html>
58. Astro <https://zed.dev/docs/languages/astro.html>
59. Bash <https://zed.dev/docs/languages/bash.html>
60. Biome <https://zed.dev/docs/languages/biome.html>
61. C <https://zed.dev/docs/languages/c.html>
62. C++ <https://zed.dev/docs/languages/cpp.html>
63. C# <https://zed.dev/docs/languages/csharp.html>
64. Clojure <https://zed.dev/docs/languages/clojure.html>
65. CSS <https://zed.dev/docs/languages/css.html>
66. Dart <https://zed.dev/docs/languages/dart.html>
67. Deno <https://zed.dev/docs/languages/deno.html>
68. Diff <https://zed.dev/docs/languages/diff.html>
69. Docker <https://zed.dev/docs/languages/docker.html>
70. Elixir <https://zed.dev/docs/languages/elixir.html>
71. Elm <https://zed.dev/docs/languages/elm.html>
72. Emmet <https://zed.dev/docs/languages/emmet.html>
73. Erlang <https://zed.dev/docs/languages/erlang.html>
74. Fish <https://zed.dev/docs/languages/fish.html>
75. GDScript <https://zed.dev/docs/languages/gdscript.html>
76. Gleam <https://zed.dev/docs/languages/gleam.html>
77. GLSL <https://zed.dev/docs/languages/glsl.html>
78. Go <https://zed.dev/docs/languages/go.html>
79. Groovy <https://zed.dev/docs/languages/groovy.html>
80. Haskell <https://zed.dev/docs/languages/haskell.html>
81. Helm <https://zed.dev/docs/languages/helm.html>
82. HTML <https://zed.dev/docs/languages/html.html>
83. Java <https://zed.dev/docs/languages/java.html>
84. JavaScript <https://zed.dev/docs/languages/javascript.html>
85. Julia <https://zed.dev/docs/languages/julia.html>
86. JSON <https://zed.dev/docs/languages/json.html>
87. Jsonnet <https://zed.dev/docs/languages/jsonnet.html>
88. Kotlin <https://zed.dev/docs/languages/kotlin.html>
89. Lua <https://zed.dev/docs/languages/lua.html>
90. Luau <https://zed.dev/docs/languages/luau.html>
91. Makefile <https://zed.dev/docs/languages/makefile.html>
92. Markdown <https://zed.dev/docs/languages/markdown.html>
93. Nim <https://zed.dev/docs/languages/nim.html>
94. OCaml <https://zed.dev/docs/languages/ocaml.html>
95. PHP <https://zed.dev/docs/languages/php.html>
96. Prisma <https://zed.dev/docs/languages/prisma.html>
97. Proto <https://zed.dev/docs/languages/proto.html>
98. PureScript <https://zed.dev/docs/languages/purescript.html>
99. Python <https://zed.dev/docs/languages/python.html>
100. R <https://zed.dev/docs/languages/r.html>
101. Rego <https://zed.dev/docs/languages/rego.html>
102. ReStructuredText <https://zed.dev/docs/languages/rst.html>
103. Racket <https://zed.dev/docs/languages/racket.html>
104. Roc <https://zed.dev/docs/languages/roc.html>
105. Ruby <https://zed.dev/docs/languages/ruby.html>
106. Rust <https://zed.dev/docs/languages/rust.html>
107. Scala <https://zed.dev/docs/languages/scala.html>
108. Scheme <https://zed.dev/docs/languages/scheme.html>
109. Shell Script <https://zed.dev/docs/languages/sh.html>
110. Svelte <https://zed.dev/docs/languages/svelte.html>
111. Swift <https://zed.dev/docs/languages/swift.html>
112. Tailwind CSS <https://zed.dev/docs/languages/tailwindcss.html>
113. Terraform <https://zed.dev/docs/languages/terraform.html>
114. TOML <https://zed.dev/docs/languages/toml.html>
115. TypeScript <https://zed.dev/docs/languages/typescript.html>
116. Uiua <https://zed.dev/docs/languages/uiua.html>
117. Vue <https://zed.dev/docs/languages/vue.html>
118. XML <https://zed.dev/docs/languages/xml.html>
119. YAML <https://zed.dev/docs/languages/yaml.html>
120. Yarn <https://zed.dev/docs/languages/yarn.html>
121. Zig <https://zed.dev/docs/languages/zig.html>
122.
123. Developing Zed
124. Developing Zed <https://zed.dev/docs/development.html>
125.
     1. macOS <https://zed.dev/docs/development/macos.html>
     2. Linux <https://zed.dev/docs/development/linux.html>
     3. Windows <https://zed.dev/docs/development/windows.html>
     4. Local Collaboration <https://zed.dev/docs/development/local-
        collaboration.html>
     5. Using Debuggers <https://zed.dev/docs/development/debuggers.html>
126. Release Process <https://zed.dev/docs/development/releases.html>
127. Debugging Crashes <https://zed.dev/docs/development/debugging-
    crashes.html>

/

/

/

/

  * Light
  * Dark

/

/

Zed Industries <https://zed.dev/>

Download <https://zed.dev/download>

On this page

Language Extensions <https://zed.dev/docs/extensions/languages#language-
extensions>Language Metadata <https://zed.dev/docs/extensions/
languages#language-metadata>Grammar <https://zed.dev/docs/extensions/
languages#grammar>Tree-sitter Queries <https://zed.dev/docs/extensions/
languages#tree-sitter-queries>Syntax highlighting <https://zed.dev/docs/
extensions/languages#syntax-highlighting>Bracket matching <https://
zed.dev/docs/extensions/languages#bracket-matching>Code outline/
structure <https://zed.dev/docs/extensions/languages#code-
outlinestructure>Auto-indentation <https://zed.dev/docs/extensions/
languages#auto-indentation>Code injections <https://zed.dev/docs/
extensions/languages#code-injections>Syntax overrides <https://zed.dev/
docs/extensions/languages#syntax-overrides>Range inclusivity <https://
zed.dev/docs/extensions/languages#range-inclusivity>Text objects
<https://zed.dev/docs/extensions/languages#text-objects>Text redactions
<https://zed.dev/docs/extensions/languages#text-redactions>Runnable code
detection <https://zed.dev/docs/extensions/languages#runnable-code-
detection>Language Servers <https://zed.dev/docs/extensions/
languages#language-servers>


  Language Extensions <#language-extensions>

Language support in Zed has several components:

  * Language metadata and configuration
  * Grammar
  * Queries
  * Language servers


    Language Metadata <#language-metadata>

Each language supported by Zed must be defined in a subdirectory inside
the |languages| directory of your extension.

This subdirectory must contain a file called |config.toml| file with the
following structure:

/

/
|name = "My Language"
grammar = "my-language"
path_suffixes = ["myl"]
line_comments = ["# "]

|

  * |name| (required) is the human readable name that will show up in
    the Select Language dropdown.
  * |grammar| (required) is the name of a grammar. Grammars are
    registered separately, described below.
  * |path_suffixes| is an array of file suffixes that should be
    associated with this language. Unlike |file_types| in settings, this
    does not support glob patterns.
  * |line_comments| is an array of strings that are used to identify
    line comments in the language. This is used for the |
    editor::ToggleComments| keybind:
    No default binding
    for toggling lines of code.
  * |tab_size| defines the indentation/tab size used for this language
    (default is |4|).
  * |hard_tabs| whether to indent with tabs (|true|) or spaces (|false|,
    the default).
  * |first_line_pattern| is a regular expression, that in addition to |
    path_suffixes| (above) or |file_types| in settings can be used to
    match files which should use this language. For example Zed uses
    this to identify Shell Scripts by matching the shebangs lines
    <https://github.com/zed-industries/zed/blob/main/crates/languages/
    src/bash/config.toml> in the first line of a script.


    Grammar <#grammar>

Zed uses the Tree-sitter <https://tree-sitter.github.io/> parsing
library to provide built-in language-specific features. There are
grammars available for many languages, and you can also develop your own
grammar <https://tree-sitter.github.io/tree-sitter/creating-
parsers#writing-the-grammar>. A growing list of Zed features are built
using pattern matching over syntax trees with Tree-sitter queries. As
mentioned above, every language that is defined in an extension must
specify the name of a Tree-sitter grammar that is used for parsing.
These grammars are then registered separately in extensions' |
extension.toml| file, like this:

/

/
|[grammars.gleam]
repository = "https://github.com/gleam-lang/tree-sitter-gleam"
rev = "58b7cac8fc14c92b0677c542610d8738c373fa81"

|

The |repository| field must specify a repository where the Tree-sitter
grammar should be loaded from, and the |rev| field must contain a Git
revision to use, such as the SHA of a Git commit. An extension can
provide multiple grammars by referencing multiple tree-sitter repositories.


    Tree-sitter Queries <#tree-sitter-queries>

Zed uses the syntax tree produced by the Tree-sitter <https://tree-
sitter.github.io/> query language to implement several features:

  * Syntax highlighting
  * Bracket matching
  * Code outline/structure
  * Auto-indentation
  * Code injections
  * Syntax overrides
  * Text redactions
  * Runnable code detection
  * Selecting classes, functions, etc.

The following sections elaborate on how Tree-sitter queries <https://
tree-sitter.github.io/tree-sitter/using-parsers#query-syntax> enable
these features in Zed, using JSON syntax <https://www.json.org/json-
en.html> as a guiding example.


      Syntax highlighting <#syntax-highlighting>

In Tree-sitter, the |highlights.scm| file defines syntax highlighting
rules for a particular syntax.

Here's an example from a |highlights.scm| for JSON:

/

/
|(string) @string

(pair
  key: (string) @property.json_key)

(number) @number

|

This query marks strings, object keys, and numbers for highlighting. The
following is a comprehensive list of captures supported by themes:

Capture	Description
@attribute	Captures attributes
@boolean	Captures boolean values
@comment	Captures comments
@comment.doc	Captures documentation comments
@constant	Captures constants
@constructor	Captures constructors
@embedded	Captures embedded content
@emphasis	Captures emphasized text
@emphasis.strong	Captures strongly emphasized text
@enum	Captures enumerations
@function	Captures functions
@hint	Captures hints
@keyword	Captures keywords
@label	Captures labels
@link_text	Captures link text
@link_uri	Captures link URIs
@number	Captures numeric values
@operator	Captures operators
@predictive	Captures predictive text
@preproc	Captures preprocessor directives
@primary	Captures primary elements
@property	Captures properties
@punctuation	Captures punctuation
@punctuation.bracket	Captures brackets
@punctuation.delimiter	Captures delimiters
@punctuation.list_marker	Captures list markers
@punctuation.special	Captures special punctuation
@string	Captures string literals
@string.escape	Captures escaped characters in strings
@string.regex	Captures regular expressions
@string.special	Captures special strings
@string.special.symbol	Captures special symbols
@tag	Captures tags
@tag.doctype	Captures doctypes (e.g., in HTML)
@text.literal	Captures literal text
@title	Captures titles
@type	Captures types
@variable	Captures variables
@variable.special	Captures special variables
@variant	Captures variants


      Bracket matching <#bracket-matching>

The |brackets.scm| file defines matching brackets.

Here's an example from a |brackets.scm| file for JSON:

/

/
|("[" @open "]" @close)
("{" @open "}" @close)
("\"" @open "\"" @close)

|

This query identifies opening and closing brackets, braces, and
quotation marks.

Capture	Description
@open	Captures opening brackets, braces, and quotes
@close	Captures closing brackets, braces, and quotes


      Code outline/structure <#code-outlinestructure>

The |outline.scm| file defines the structure for the code outline.

Here's an example from an |outline.scm| file for JSON:

/

/
|(pair
  key: (string (string_content) @name)) @item

|

This query captures object keys for the outline structure.

Capture	Description
@name	Captures the content of object keys
@item	Captures the entire key-value pair
@context	Captures elements that provide context for the outline item
@context.extra	Captures additional contextual information for the
outline item
@annotation	Captures nodes that annotate outline item (doc comments,
attributes, decorators)^1 <#1>

^1

These annotations are used by Assistant when generating code
modification steps.


      Auto-indentation <#auto-indentation>

The |indents.scm| file defines indentation rules.

Here's an example from an |indents.scm| file for JSON:

/

/
|(array "]" @end) @indent
(object "}" @end) @indent

|

This query marks the end of arrays and objects for indentation purposes.

Capture	Description
@end	Captures closing brackets and braces
@indent	Captures entire arrays and objects for indentation


      Code injections <#code-injections>

The |injections.scm| file defines rules for embedding one language
within another, such as code blocks in Markdown or SQL queries in Python
strings.

Here's an example from an |injections.scm| file for Markdown:

/

/
|(fenced_code_block
  (info_string
    (language) @injection.language)
  (code_fence_content) @injection.content)

((inline) @content
 (#set! injection.language "markdown-inline"))

|

This query identifies fenced code blocks, capturing the language
specified in the info string and the content within the block. It also
captures inline content and sets its language to "markdown-inline".

Capture	Description
@injection.language	Captures the language identifier for a code block
@injection.content	Captures the content to be treated as a different
language

Note that we couldn't use JSON as an example here because it doesn't
support language injections.


      Syntax overrides <#syntax-overrides>

The |overrides.scm| file defines syntactic /scopes/ that can be used to
override certain editor settings within specific language constructs.

For example, there is a language-specific setting called |
word_characters| that controls which non-alphabetic characters are
considered part of a word, for example when you double click to select a
variable. In JavaScript, "$" and "#" are considered word characters.

There is also a language-specific setting called |
completion_query_characters| that controls which characters trigger
autocomplete suggestions. In JavaScript, when your cursor is within a /
string/, "-" is should be considered a completion query character. To
achieve this, the JavaScript |overrides.scm| file contains the following
pattern:

/

/
|[
  (string)
  (template_string)
] @string

|

And the JavaScript |config.toml| contains this setting:

/

/
|word_characters = ["#", "$"]

[overrides.string]
completion_query_characters = ["-"]

|

You can also disable certain auto-closing brackets in a specific scope.
For example, to prevent auto-closing |'| within strings, you could put
the following in the JavaScript |config.toml|:

/

/
|brackets = [
  { start = "'", end = "'", close = true, newline = false, not_in = ["string"] },
  # other pairs...
]

|


        Range inclusivity <#range-inclusivity>

By default, the ranges defined in |overrides.scm| are /exclusive/. So in
the case above, if you cursor was /outside/ the quotation marks
delimiting the string, the |string| scope would not take effect.
Sometimes, you may want to make the range /inclusive/. You can do this
by adding the |.inclusive| suffix to the capture name in the query.

For example, in JavaScript, we also disable auto-closing of single
quotes within comments. And the comment scope must extend all the way to
the newline after a line comment. To achieve this, the JavaScript |
overrides.scm| contains the following pattern:

/

/
|(comment) @comment.inclusive

|


      Text objects <#text-objects>

The |textobjects.scm| file defines rules for navigating by text objects.
This was added in Zed v0.165 and is currently used only in Vim mode.

Vim provides two levels of granularity for navigating around files.
Section-by-section with |[]| etc., and method-by-method with |]m| etc.
Even languages that don't support functions and classes can work well by
defining similar concepts. For example CSS defines a rule-set as a
method, and a media-query as a class.

For languages with closures, these typically should not count as
functions in Zed. This is best-effort however, as languages like
Javascript do not syntactically differentiate syntactically between
closures and top-level function declarations.

For languages with declarations like C, provide queries that match |
@class.around| or |@function.around|. The |if| and |ic| text objects
will default to these if there is no inside.

If you are not sure what to put in textobjects.scm, both nvim-
treesitter-textobjects <https://github.com/nvim-treesitter/nvim-
treesitter-textobjects>, and the Helix editor <https://github.com/helix-
editor/helix> have queries for many languages. You can refer to the Zed
built-in languages <https://github.com/zed-industries/zed/tree/main/
crates/languages/src> to see how to adapt these.

Capture	Description	Vim mode
@function.around	An entire function definition or equivalent small
section of a file.	|[m|, |]m|, |[M|,|]M| motions. |af| text object
@function.inside	The function body (the stuff within the braces).	|if|
text object
@class.around	An entire class definition or equivalent large section of
a file.	|[[|, |]]|, |[]|, |][| motions. |ac| text object
@class.inside	The contents of a class definition.	|ic| text object
@comment.around	An entire comment (e.g. all adjacent line comments, or a
block comment)	|gc| text object
@comment.inside	The contents of a comment	|igc| text object (rarely
supported)

For example:

/

/
|; include only the content of the method in the function
(method_definition
    body: (_
        "{"
        (_)* @function.inside
        "}")) @function.around

; match function.around for declarations with no body
(function_signature_item) @function.around

; join all adjacent comments into one
(comment)+ @comment.around

|


      Text redactions <#text-redactions>

The |redactions.scm| file defines text redaction rules. When
collaborating and sharing your screen, it makes sure that certain syntax
nodes are rendered in a redacted mode to avoid them from leaking.

Here's an example from a |redactions.scm| file for JSON:

/

/
|(pair value: (number) @redact)
(pair value: (string) @redact)
(array (number) @redact)
(array (string) @redact)

|

This query marks number and string values in key-value pairs and arrays
for redaction.

Capture	Description
@redact	Captures values to be redacted


      Runnable code detection <#runnable-code-detection>

The |runnables.scm| file defines rules for detecting runnable code.

Here's an example from an |runnables.scm| file for JSON:

/

/
|(
    (document
        (object
            (pair
                key: (string
                    (string_content) @_name
                    (#eq? @_name "scripts")
                )
                value: (object
                    (pair
                        key: (string (string_content) @run @script)
                    )
                )
            )
        )
    )
    (#set! tag package-script)
    (#set! tag composer-script)
)

|

This query detects runnable scripts in package.json and composer.json files.

The |@run| capture specifies where the run button should appear in the
editor. Other captures, except those prefixed with an underscore, are
exposed as environment variables with a prefix of |
ZED_CUSTOM_$(capture_name)| when running the code.

Capture	Description
@_name	Captures the "scripts" key
@run	Captures the script name
@script	Also captures the script name (for different purposes)


    Language Servers <#language-servers>

Zed uses the Language Server Protocol <https://microsoft.github.io/
language-server-protocol/> to provide advanced language support.

An extension may provide any number of language servers. To provide a
language server from your extension, add an entry to your |
extension.toml| with the name of your language server and the
language(s) it applies to:

/

/
|[language_servers.my-language]
name = "My Language LSP"
languages = ["My Language"]

|

Then, in the Rust code for your extension, implement the |
language_server_command| method on your extension:

/

/
|#![allow(unused)]
fn main() {
impl zed::Extension for MyExtension {
    fn language_server_command(
        &mut self,
        language_server_id: &LanguageServerId,
        worktree: &zed::Worktree,
    ) -> Result<zed::Command> {
        Ok(zed::Command {
            command: get_path_to_language_server_executable()?,
            args: get_args_for_language_server()?,
            env: get_env_for_language_server()?,
        })
    }
}
}

|

You can customize the handling of the language server using several
optional methods in the |Extension| trait. For example, you can control
how completions are styled using the |label_for_completion| method. For
a complete list of methods, see the API docs for the Zed extension API
<https://docs.rs/zed_extension_api>.

